'''
импорт библиотеки для создания массивов и встроенных высокооптимизированных
функций
'''
import numpy as np

def wFunc (xDist, x1Dist):
    '''
    Функция вычисляет вес очередного соседа, относительно k+1 соседа

    Parameters
    ----------
    xDist : float
        Расстояние до очередного соседа.
    x1Dist : float
        Расстояние до k+1 соседа.

    Returns
    -------
    kernel : float
        Вес очередного соседа.

    '''
    
    '''
    Вычисление отношения расстояния до очередного соседа к расстоянию до
    k+1 соседа
    '''
    arg = xDist/x1Dist
    
    # Ядро отлично от нуля на отрезке [0, 1]
    if (arg >= 0):
        
        # Вычисление ядра
        kernel = 1 - pow(arg, 2)
    else:
        kernel = 0
    return kernel



def regressionKNN(k, testDF, sortDist, sortLabels, one_elem_pred = False):
    
    '''
    Функция вычисляет значение неизвестного параметра объекта на основе 
    k ближайших соседей
    
    Parameters
    ----------
    k : int
        Количество учитываемых соседей.
    testDF : Matrix
        Набор тестовых данных
    sortDist : Matrix
        матрица сортированных расстояний до к ближайших соседей.
    sortLabels : Matrix
        матрица меток ближайших к соседей.
    one_elem_pred : bool, optional
        флаг предсказания одного объекта. The default is False.
    
    Returns
    ------
    a : array
        массив предсказанных значений неизвестного параметра для тестового
        набора данных.
    '''
    
    '''
    инициализация переменной для формирования массива предсказаний неизвестного
    параметра
    '''
    a = []
    
    '''
    Ветвление вызванное разным преобразованием метода to_numpy, которое
    неправильно интерпретирует набор тренировочных данных, если тестовые данные
    заданы набором атрибутов одного объекта, из-за чего происходит неправильное
    обращение к переменной, в которую записан этот элемент.
    
    Если значение переменной one_elem_pred ложно - выполняется ветка if,
    если истино - выполняется ветка else
    '''
    if (one_elem_pred == False):
        
        '''
        Инициализация цикла с количеством итераций равным количеству объектов
        в тестовом наборе данных
        '''
        for i in range(len(testDF)):
            
            # Инициализация переменной для записи весов ближайших соседей
            weights = []
            
            # Формирование весов с помощью инициализированной функции в цикле
            for j in range(k):
                weights.append(wFunc(sortDist[i][j], sortDist[i][k]))
            
            '''
            Формирование числителя с помощью суммы результатов поэлементного
            умножения массивов весов и целевых меток ближайших соседей с
            помощью оптимизированной функции inner из библиотеки numpy
            '''
            numerator = np.inner(weights, sortLabels[i][:k])
            
            '''
            Формирование знаменателя путём суммирования элеменов массива
            весов, полученного на данной итерации цикла
            '''
            denominator = np.sum(weights)
            
            '''
            Вычисление неизвестной характеристики очередного объекта из
            тестового датасета и добавление полученного значения к выходному
            массиву
            '''
            a.append(numerator/denominator)
    
    # Начало второй ветки
    else:
        
        # Инициализация переменной для записи весов ближайших соседей
        weights = []
        
        # Формирование весов с помощью инициализированной функции в цикле
        for j in range(k):
            weights.append(wFunc(sortDist[j], sortDist[k]))
            
        '''
        Вычисление неизвестной характеристики тестового объекта аналогично
        предыдущей ветке
        '''
        numerator = np.inner(weights, sortLabels[:k])
        denumerator = np.sum(weights)
        a = numerator/denumerator
    return a