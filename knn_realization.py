# библиотека с математическими функциями
import math

'''
импорт библиотеки для создания массивов и встроенных высокооптимизированных
функций
'''
import numpy as np

def KNN(k_func, trainSetFunc, testSetFunc, one_elem_pred = False):
    '''
    Функция реализует формирование матриц расстояний до ближайших соседей и
    их целевых меток
    
    Parameters
    ----------
    k_func : int
        Число ближайших соседей, для которых определяется расстояние.
    trainSetFunc : DataFrame
        Набор тренировочных данных.
    testSetFunc : DataFrame or one-dimention row
        Набор тестовых данных.
    one_elem_pred : bool, optional
        флаг предсказания одного объекта. The default is False.

    Returns
    -------
    out_dist : matrix
        Расстояние до к ближайших соседей.
    out_label : matrix
        Метка соответствующих сосдей.

    '''
    
    '''
    преобразование тестового и тренировочного наборов данных для ускорения
    вычислений
    '''
    testSetNP = testSetFunc.to_numpy()
    trainSetNP = trainSetFunc.to_numpy()
    
    '''
    инициализация пременных для формирования массива меток ближайших
    соседей, выходной матрицы меток ближайших соседей, массива расстояний до 
    ближайших соседей и матрицы расстояний до ближайших соседей, соответственно
    '''
    nearest_neighbors = []
    out_label = []
    min_dist = []
    out_dist = []
    
    # инкрементирование параметра k для записи информации о k+1 соседе
    k_func += 1
    
    # обнуление счётчика
    n = 0
    
    # вычисление порядкового номера столбца целевых меток
    n_label = len(trainSetFunc.columns) - 1
    
    '''
    Ветвление вызванное разным преобразованием метода to_numpy, которое
    неправильно интерпретирует набор тренировочных данных, если тестовые данные
    заданы набором атрибутов одного объекта, из-за чего происходит неправильное
    обращение к переменной, в которую записан этот элемент.
    
    Если значение переменной one_elem_pred ложно - выполняется ветка if,
    если истино - выполняется ветка else
    '''
    if (one_elem_pred == False):
        
        '''
        приведение матриц расстояний до ближайших соседей и их меток к размеру
        тестового датасета
        '''
        for i in range(len(testSetNP)):
            out_dist.append([])
            out_label.append([])
            for d in range(k_func):
                out_dist[i].append(0)
                out_label[i].append(0)
        
        '''
        Приведение массивов расстояний до ближайших соседей и их меток к
        размеру, соответствующую количеству учитываемых ближайших соседей
        '''
        for i in range(k_func):
            nearest_neighbors.append(0)
            min_dist.append(0)
        
        # Инициализация цикла прохода по набору тестовых данных
        for testElem in testSetNP:
            
            '''
            Приведение массивов расстояний до ближайших соседей и их меток в
            исходное состояние
            '''
            for i in range(k_func):
                nearest_neighbors[i] = 0
                min_dist[i] = math.inf
            
            '''
            Инициализация внутреннего цикла прохода по тренировочному датасету
            '''
            for trainElem in trainSetNP:
                
                '''
                Вычисление евклидового расстояния.
                
                Сначала вычисляется разница между атрибулами рассматриваемого
                объекта из тестового датасета с очередным объектом из трениро-
                вочного датасета. Данная операция поэлементного вычитания двух
                массивов реализована в оптимизированной библиотеке numpy.
                
                Затем вычисляется корень суммы квадратов полученных разностей
                с помощью метода linalg из библиотеки numpy
                '''
                dist = np.linalg.norm(testElem[:n_label] - trainElem[:n_label])
                
                #  обнуление счётчика
                i = 0
                
                '''
                Цикл сравнения полученного расстояния с записанными в массив
                расстояний до ближайших соседей
                '''
                while (min_dist[i] < dist and i != (k_func-1)):
                    i += 1
                    
                '''
                Если в результате выполнения предыдущего цикла найден индекс,
                который указывает на наименьшее расстояние, записанное в массив
                расстояний до ближайших соседей рассматриваемого элемента из
                тестового датасета, то все остальные бОльшие расстояния
                переходят в индекс на 1 старше, a данное расстояние встает 
                на его место
                '''
                if (min_dist[i] > dist):
                    for j in range(k_func-i):
                        nearest_neighbors[k_func-j-1] = (
                            nearest_neighbors[k_func-j-2])
                        min_dist[k_func-j-1] = min_dist[k_func-j-2]
                    nearest_neighbors[i] = trainElem[n_label]
                    min_dist[i] = dist
            
            '''
            Запись полученных в цикле расстояний до ближайших соседей из
            тренировочного датасета и их меток, соответствующих n-ому объекту
            из тестового датасета соотвтетствующие матрицы
            '''
            for d in range(k_func):
                out_dist[n][d] = min_dist[d]
                out_label[n][d] = nearest_neighbors[d]
            
            # инкрементирование счётчика
            n += 1
            
    # Начало второй ветки 
    else:
        
        '''
        Приведение массивов расстояний до ближайших соседей и их меток в
        исходное состояние
        '''
        for i in range(k_func):
            nearest_neighbors.append(0)
            min_dist.append(math.inf)
            
        # Инициализация цикла прохода по тренировочному датасету
        for trainElem in trainSetNP:
            
            # Вычисление евклидового расстояния
            dist = np.linalg.norm(testSetNP[:n_label] - trainElem[:n_label])
            
            # обнуление счётчика
            i = 0
            
            '''
            Цикл сравнения полученного расстояния с записанными в массив
            расстояний до ближайших соседей
            ''' 
            while(min_dist[i] < dist and i != (k_func-1)):
                i += 1
            
            '''
            Если в результате выполнения предыдущего цикла найден индекс,
            который указывает на наименьшее расстояние, записанное в массив
            расстояний до ближайших соседей рассматриваемого элемента из
            тестового датасета, то все остальные бОльшие расстояния
            переходят в индекс на 1 старше, a данное расстояние встает 
            на его место
            '''
            if (min_dist[i] > dist):
                for j in range(k_func-i):
                    nearest_neighbors[k_func-j-1] = (
                        nearest_neighbors[k_func-j-2])
                    min_dist[k_func-j-1] = min_dist[k_func-j-2]
                nearest_neighbors[i] = trainElem[n_label]
                min_dist[i] = dist
        
        '''
        Запись полученных в цикле расстояний до ближайших соседей из
        тренировочного датасета и их меток, соответствующих n-ому объекту
        из тестового датасета соотвтетствующие матрицы
        '''
        out_dist = min_dist
        out_label = nearest_neighbors
    
    return out_dist, out_label